= MultiJuicer Codebase 101 & Contributor's Guide

This document serves as the main entry point for the MultiJuicer 
codebase. It provides an overview of the codebase, its structure, 
and how to navigate it as a contributor. We recommend reading 
through the xref:part3/contribution.adoc[contributing guide of Juice Shop 
to learn about the common standards and practices]. Also, this is a 
project based on Golang and Kubernetes. Getting familiar with these technologies 
will be essential for contributing effectively:

* **Go Programming Language**: MultiJuicer's backend components are written in Go. 
If you're new to Go, start with the 
https://go.dev/doc/tutorial/getting-started[official Go tutorial] 
and refer to the https://go.dev/doc/effective_go[Effective Go] 
guide for best practices.

* **Kubernetes**: The project heavily relies on Kubernetes for orchestration and 
resource management. 
The https://kubernetes.io/docs/tutorials/kubernetes-basics/[Kubernetes Basics tutorial] and 
https://kubernetes.io/docs/reference/[API reference documentation] are excellent 
starting points.
The https://kubernetes.io/docs/tasks/[Tasks section] provides practical examples 
for common operations.

It is not required to go in depth but at the very least basic understanding of Kubernetes
and Go syntax would be appreciated.

== Table of Contents

1. <<what-is-multijuicer,What is MultiJuicer?>>
2. <<high-level-architecture,High-Level Architecture>>

== What is MultiJuicer? [[what-is-multijuicer]]

As described in the main `readme.md`, MultiJuicer solves the 
challenge of running OWASP Juice Shop instances for multiple 
users simultaneously, typically during CTFs or security training 
sessions. It provides a central platform on Kubernetes that 
dynamically provisions and manages isolated Juice Shop instances 
for each team or participant.

=== Core Features

* **Dynamic Instance Provisioning:** Creates Juice Shop instances
 on demand when a team joins.
* **Load Balancing/Proxying:** Routes user traffic to their 
specific Juice Shop instance based on a secure cookie.
* **Progress Persistence:** Backs up solved challenges 
to Kubernetes annotations,
 allowing progress to survive pod restarts.
* **Automated Cleanup:** Removes old, inactive instances 
based on a configurable duration.
* **Scoreboard & Admin UI:** Provides visibility into 
team progress and administrative controls.

== High-Level Architecture [[high-level-architecture]]

MultiJuicer consists of three main backend components running in 
Kubernetes, plus a frontend UI served by the Balancer:

1. **Balancer:**
   * The main user entry point.
   * Serves the React-based UI for joining/creating teams and viewing 
   status/scores.
   * Handles API requests for team management (join, logout, reset passcode).
   * Creates/manages Kubernetes `Deployment` and `Service` resources 
   for each Juice Shop instance.
   * Acts as a reverse proxy, routing authenticated user traffic to 
   their corresponding Juice Shop instance.
   * Provides an admin interface for managing instances.
   * Calculates and caches scoreboard data.
2. **Progress Watchdog:**
   * Listens for webhook notifications sent by individual Juice Shop 
   instances when a challenge is solved.
   * Patches the corresponding team's Kubernetes `Deployment` resource, 
   updating annotations (`multi-juicer.owasp-juice.shop/...`) to 
   store the list of solved challenges, and the count
   * Includes a background sync mechanism to periodically check 
   running Juice Shops and ensure annotation data matches the 
   instance's state, applying backed-up progress if needed.
3. **Cleaner:**
   * Runs periodically as a Kubernetes `CronJob`.
   * Lists all Juice Shop `Deployment` resources managed by MultiJuicer.
   * Checks the `multi-juicer.owasp-juice.shop/lastRequest` annotation 
   timestamp.
   * If an instance has been inactive for longer than the configured 
   duration (`MAX_INACTIVE_DURATION`), it deletes the corresponding 
   `Deployment` and `Service`.

image::part3/high-level-architecture.svg[MultiJuicer, High Level Architecture Diagram]

== Repository Structure

[source, shell]
----
└── multi-juicer
    ├── balancer/            # The core Balancer component (Go backend + React UI)
    │   ├── pkg/             # Shared Go packages for the balancer (bundle,                       passcode, scoring, etc.)
    │   ├── routes/          # HTTP route handlers for the Go backend API and proxy
    │   ├── ui/              # React frontend source code
    │   ├── Dockerfile       # Builds the balancer image (includes UI build)
    │   └── main.go          # Entry point for the balancer backend
    ├── cleaner/             # The Cleaner component (Go)
    │   ├── Dockerfile       # Builds the cleaner image
    │   └── main.go          # Entry point and logic for the cleaner CronJob
    ├── guides/              # Setup guides for different environments (AWS, Azure,              DigitalOcean, K8s, etc.)
    ├── helm/                # Helm chart for deploying MultiJuicer
    │   └── multi-juicer/    # The main chart directory
    │       ├── templates/   # Kubernetes manifest templates for all components
    │       ├── dashboards/  # Grafana dashboard definition
    │       ├── Chart.yaml   # Chart metadata
    │       └── values.yaml  # Default configuration values for the chart
    ├── progress-watchdog/   # The Progress Watchdog component (Go)
    │   ├── internal/        # Core logic (Kubernetes interaction, background sync, etc.)
    │   ├── Dockerfile       # Builds the progress-watchdog image
    │   └── main.go          # Entry point, webhook listener
    ├── build-and-deploy.sh  # Helper script for local development builds/deploys
    └── Taskfile.yaml        # Task definitions for development (linting, testing,           building)
----

=== 4. Component Deep Dive

==== Balancer

* **Location:** `balancer/`
* **Purpose:** User interaction hub, instance management, request 
proxying, admin interface, scoreboard provider.
* **Technology:** Go (`net/http` mux, `client-go`), React (Vite, 
Tailwind CSS, React Router, `react-intl`).
* **Key Files/Logic:**
  * `main.go`: Sets up HTTP routes using `routes.AddRoutes`, starts 
  the scoring service worker (`scoring.StartingScoringWorker`), 
  and runs the main HTTP server. Also starts a separate metrics 
  server on `:8081`.
  * `routes/routes.go`: Defines all HTTP endpoints and associates 
  them with handlers. Uses `promhttp.InstrumentHandlerCounter` for metrics.
  * `routes/join.go`:
    * Handles `POST /balancer/api/teams/{team}/join`.
    * Checks if team exists via `getDeployment`.
    * If new team: Checks instance limit (`isMaxInstanceLimitReached`), 
    generates passcode (`generatePasscode` using `bcrypt`), creates 
    K8s Deployment (`createDeploymentForTeam`) and Service 
    (`createServiceForTeam`). Sets `OwnerReferences` to link 
    resources to the balancer deployment itself.
    * If existing team: Validates provided passcode against the 
    `passcode` annotation using `bcrypt.CompareHashAndPassword`.
    * Handles special 'admin' team login against 
    `MULTI_JUICER_CONFIG_ADMIN_PASSWORD` env var.
    * Sets a signed cookie (`setSignedTeamCookie`) upon 
    successful join/creation.
  * `routes/proxy.go`:
    * Handles all non-API/non-balancer routes (`/`).
    * Verifies the signed team cookie using `teamcookie.GetTeamFromRequest`. 
    Redirects to `/balancer` if invalid/missing.
    * Checks if the instance is ready using `isInstanceUp` 
    (checks `ReadyReplicas` on the Deployment). Caches the 'up' 
    status briefly (`instanceUpCache`).
    * If ready, updates the `lastRequest` annotation 
    (`updateLastRequestTimestamp`) and proxies the request using 
    `httputil.NewSingleHostReverseProxy` to the target determined 
    by `bundle.GetJuiceShopUrlForTeam`.
    * If not ready/missing, redirects the user to the status page 
    with appropriate query parameters (`msg=instance-restarting` 
    or `msg=instance-not-found`).
  * `routes/teamStatus.go`, `routes/score-board.go`, 
  `routes/individualScore.go`: Fetch data from the `scoring.ScoringService`
   and return JSON responses. Support optional long-polling 
   via `wait-for-update-after` query param.
  * `routes/admin*.go`: Provide admin functionality (listing, 
  deleting, restarting instances). Authenticated by checking 
  for the 'admin' team cookie. Interact directly with the 
  Kubernetes API via `clientset`.
  * `routes/staticFiles.go`: Serves the React frontend build 
  artifacts from `/balancer/ui/build/`, including handling 
  client-side routing by serving `index.html` for specific paths.
  * `pkg/bundle/bundle.go`: Central struct (`Bundle`) holding 
  configuration (read from `/config/config.json` mounted from 
  ConfigMap, and environment variables like `NAMESPACE`, 
  `MULTI_JUICER_CONFIG_COOKIE_SIGNING_KEY`, `MULTI_JUICER_CONFIG_ADMIN_PASSWORD`), 
  the Kubernetes `clientset`, logger, and utility functions 
  (like `GetJuiceShopUrlForTeam`). Acts as a dependency 
  injection mechanism. Also loads `/challenges.json` 
  (copied during build) for scoring.
  * `pkg/scoring/scoring.go`: `ScoringService` calculates 
  team scores based on the `challenges` annotation on Deployments.
   It maintains an in-memory cache (`currentScores`, `currentScoresSorted`)
    and uses a Kubernetes `Watch` (`startScoringWatcher`) on
     Deployments to update scores in near real-time. Provides 
     methods like `GetTopScores`, `GetScoreForTeam`, and `WaitForUpdatesNewerThan` 
     for long polling.
  * `pkg/signutil/signutil.go` & `pkg/teamcookie/signutil.go`: 
  Handle HMAC-SHA256 signing and verification of the team name 
  stored in the cookie. Uses the `MULTI_JUICER_CONFIG_COOKIE_SIGNING_KEY`.
  * `ui/src/`: Contains the React frontend code. Key pages include
   `JoinPage.tsx`, `JoiningPage.tsx`, `TeamStatusPage.tsx`,
    `ScoreOverview.tsx`, `IndividualScorePage.tsx`, and `AdminPage.tsx`.
     Uses `react-router-dom` for routing and `react-intl` for internationalization.